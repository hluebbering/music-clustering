---
title: "Data Programming with Python"
author: "Hannah Luebbering"
date: "July 04, 2022"
output: 
  html_document: 
    css: "assets/main2.css"
    toc: yes
    toc_float: yes
knit: (function(inputFile, encoding) {rmarkdown::render(inputFile, encoding = encoding, output_dir = "docs") })
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, out.width = "80%")
library(kableExtra)
library(knitr)
library(ggplot2)
library(hrbrthemes)
library(lubridate)
library(GGally)
library(ggrepel)
library(spotifyr)
library(tidyverse)
library(shiny)
library(shinydashboard)
library(magick)
library(genius)
library(tidytext)
library(geniusr)
library(dplyr)

source('scripts/data.R')
```



<script src="assets/min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script src="assets/pymin.js"></script>
<script>hljs.initHighlightingOnLoad();</script>




- Generate a playlist from a song
- Generate a playlist from a playlist
- Edit a playlist
- Get lyrics: determine most used drug names from lyrics
  - predict mainstream drug usage








```{r}
juice_wrld <- spotifyr::get_artist_audio_features(artist = 'Juice Wrld')
juice_wrld <- juice_wrld %>% dplyr::select('track_name','artist_name','artist_id','artists','album_release_date','album_name','danceability','energy','key','loudness','speechiness','acousticness','instrumentalness','liveness','valence','tempo','duration_ms','key_name')

juice_wrld_id <- unique(juice_wrld$artist_id)
juice_wrld_top_tracks <- spotifyr::get_artist_top_tracks(juice_wrld_id)
juice_wrld_top_tracks <- juice_wrld_top_tracks %>%
  dplyr::select('artists', 'name','popularity','album.name')

juice_wrld

```




```{r, message=FALSE, warning=FALSE}
x1 <- juice_wrld$track_name[4]
x2 <- juice_wrld$artist_name[3]
x3 <- juice_wrld$album_name[3]

 

#get_lyrics <- get_discography(x2) %>%dplyr::filter(track_name == x1)
 


get_lyrics_search(artist_name = x2, song_title = x1) %>% 
  unnest_tokens(bigram, line, token = "ngrams", n = 2) # get lyric bigrams
```

```{r}
get_lyrics_search(artist_name = "Kanye West",
                  song_title = "Good Morning") %>%
  unnest_tokens(bigram, line, token = "ngrams", n = 2) %>%
  filter(bigram == "good morning") %>% 
  nrow() # count bigram frequency


```



```{r}
plotA <- ggplot(data = juice_wrld) +
  geom_bar(mapping = aes(x=album_name, y = energy),stat = 'identity')  +
  coord_flip() +
  hrbrthemes::theme_ipsum_rc() +
  theme(legend.position = "none")

plotA
```






------------------------------------------------





## Comparing Multiple Playlists



<span class = "myhighlight">Overview:</span> Given a list of playlists, find all duplicated songs.








### Part 1.


Write a function called `common_artists(artists)` that takes in a list of sets representing musical artist names and returns a float representing the fraction of common artists shared among the sets. The **fraction of common artists** is the number of shared artists divided by the total number of unique artists that appeared across all sets. 


Our assumptions include that the given list `artists` contains at least one set, although the length of the set may or may not be empty. In the case that artists contains at least one empty set, return 0.0.




By definition, a set is a data structure that contains values where order does not matter and there're no duplicates. To find common elements in both set1 and set2, we run `set1 & set2`.



<div class = "termy">



```{python}
def common_artists(artists):
  # Create empty dictionary for unique artists
  artist_counts = dict()
  
  # Loop through list of sets
  for a_set in artists:
    
    # Loop through names in set
    for name in a_set:
      
      # Update current artist's count
      if name in artist_counts:
        artist_counts[name] += 1
      else:
        artist_counts[name] = 1
  
  # Total number of unique artists across all sets
  unique_artists = len(artist_counts)
  shared_artists = 0
  
  # Find artists shared across all sets
  for freq in artist_counts.values():
    if freq == len(artists):
      shared_artists += 1
      
      
  return(float(shared_artists / unique_artists))
```






```{python}
common_artists([
  {"Kanye West", "Post Malone"}, {"Kanye West", "Miley Cyrus", "Post Malone"},
  {"Kanye West", "Justin Bieber"}])
```




</div>



There is one artist (Kanye West) shared across all sets while there are four unique artists (Kanye West, Post Malone, Miley Cyrus, and Justin Bieber). Thus, our fraction of common artists percentage is $1/4 = 0.25$.






















-----------------------------------





### Part 2.


<span class = "myhighlight5">Problem 2</span>


Write a function called `explore_seattle(seattle_map, curr_location)`, where `seattle_map` is a list of tuples. Each tuple has two elements: the first element is the name of the location and the second element is a tuple containing the x and y-coordinates of the given location. `curr_location` is a tuple giving your x and y-coordinates of your location.


You will want to calculate the distance between you and all of the locations and return a list of all the location names. This list should be sorted first by distance between you and the location in ascending order, and any ties in distance are broken by alphabetical order of the location names.







The **euclidean distance** is a simple way to calculate the distance between two data points representing the $x$ and $y$-coordinates of the given location. To calculate the euclidean distance, we use the Pythagorean theorem. If we have two data points $a=\left[a_1, a_2, \ldots , a_n\right]$ and $b=\left[b_1, b_2, \ldots , b_n\right]$, where $n$ is the dimension, we define the euclidean distance between both points as

$$
\begin{align}
D (a,b) &=
\sqrt{(a_1 - b_1)^2 + (a_2-b_2)^2 + \ldots + (a_n-b_n)^2}
\end{align}
$$












-----------------------------------











------------------------------------


